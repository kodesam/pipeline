Here's an example YAML configuration for creating a Kubernetes Pod that includes a Secret, a ConfigMap, and a Network Policy for a web server:

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  username: <base64-encoded-username>
  password: <base64-encoded-password>

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-configmap
data:
  app_config: |
    server_port: 8080
    log_level: DEBUG

---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: webserver-policy
spec:
  podSelector:
    matchLabels:
      role: web-server
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - podSelector:
            matchLabels:
              role: db-server
        ports:
          - protocol: TCP
            port: 3306
  egress:
    - to:
        - podSelector:
            matchLabels:
              role: db-server
        ports:
          - protocol: TCP
            port: 3306

---
apiVersion: v1
kind: Pod
metadata:
  name: web-server-pod
  labels:
    role: web-server
spec:
  containers:
    - name: web-server-container
      image: nginx:latest
      ports:
        - containerPort: 80
      env:
        - name: USERNAME
          valueFrom:
            secretKeyRef:
              name: my-secret
              key: username
        - name: PASSWORD
          valueFrom:
            secretKeyRef:
              name: my-secret
              key: password
      volumeMounts:
        - name: config-volume
          mountPath: /etc/app/config
  volumes:
    - name: config-volume
      configMap:
        name: my-configmap
```

You can save this configuration in a file (e.g., `webserver-pod.yaml`) and apply it to your Kubernetes cluster using the `kubectl apply -f webserver-pod.yaml` command. This configuration will create a Pod with a web server container that uses a Secret for authentication, a ConfigMap for configuration settings, and a Network Policy to control network traffic between the web server and a database server.
